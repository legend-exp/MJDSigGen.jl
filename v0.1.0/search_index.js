var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:module]","category":"page"},{"location":"api/#Types-and-constants","page":"API","title":"Types and constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:type, :constant]","category":"page"},{"location":"api/#Functions-and-macros","page":"API","title":"Functions and macros","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order = [:macro, :function]","category":"page"},{"location":"api/#Documentation","page":"API","title":"Documentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [MJDSigGen]\nOrder = [:module, :type, :constant, :macro, :function]","category":"page"},{"location":"api/#MJDSigGen.nearest_field_grid_index-Tuple{SigGenSetup, Tuple{Real, Real, Real}}","page":"API","title":"MJDSigGen.nearest_field_grid_index","text":"nearest_field_grid_index(setup::SigGenSetup, location::NTuple{3, Real})\n\nReturns:\n\n(:outside, i, j), if outside crystal or too far from a valid grid point\n(:interpol, i, j, if interpolation is okay\n(:extrapol, i, j), if we can find a point but extrapolation is needed\n\n\n\n\n\n","category":"method"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#MJDSigGen.jl","page":"Home","title":"MJDSigGen.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MJDSigGen.jl provides a Julia wrapper around David Radford's field-calculation and signal-generation package for non-segmented high-purity Germanium detectors, mjd_siggen.","category":"page"},{"location":"#Basic-Usage","page":"Home","title":"Basic Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To get started you'll need a config file to specify detector geometry and some simulation parameters. See the example.config to get started. Next, you'll need a lookup table of drift velocities as in drift\\_vel\\_torr.tab. See that the drift_name field in the config file matches the relative path from the config to the velocity table file.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we can start using MJDSigGen. If you haven't installed it already, install it as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(url=\"https://github.com/legend-exp/MJDSigGen.jl.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"We'll also need the weighting field, potential and electric field in the detector. To simulate these we use the fieldgen function as follows (This may take a while). The electric field data and the weighting potential data will be written to the files specified in the config under field_name and wp_name respectively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using MJDSigGen;\n\njulia> fieldgen(\"examples/config/example.config\");","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can now start simulating signals. Initialise a SigGenSetup object like so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> setup = SigGenSetup(\"examples/config/example.config\");","category":"page"},{"location":"","page":"Home","title":"Home","text":"To simulate a signal produced by a drifting charge cluster starting at (10, 10, 10) (x, y, z), do:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> get_signal!(setup, (10, 10, 10))\nq: -1.0 t: 122 n: 1 ((10.00 10.00 10.00)=>(12.67 12.67 -0.20))\nq: 1.0 t: 375 n: 1 ((10.00 10.00 10.00)=>(0.80 0.80 -0.18))\n800-element Array{Float32,1}:\n 0.0014776316\n 0.0047704997\n 0.008109845\n 0.011552348\n 0.015177331\n ⋮\n 1.0000001\n 1.0000001\n 1.0000001\n 1.0000001","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can also look at the path, velocity or cluster size of the last simulation by examining the relevant properties of our setup object. For example, to see the velocity of the holes cluster, we can use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> setup.instant_vel_h\n8000×3 LinearAlgebra.Transpose{Float32,Base.ReshapedArray{Float32,2,Base.ReinterpretArray{Float32,1,MJDSigGen.CartPoint{Float32},Array{MJDSigGen.CartPoint{Float32},1}},Tuple{}}}:\n -0.0332866  -0.0332866  0.0399359\n -0.0333873  -0.0333873  0.0394825\n -0.0334852  -0.0334852  0.0390309\n -0.0335816  -0.0335816  0.0385836\n -0.0336817  -0.0336817  0.0381274\n  ⋮                      \n  0.0         0.0        0.0\n  0.0         0.0        0.0\n  0.0         0.0        0.0\n  0.0         0.0        0.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"The three columns refer to x, y and z components respectively. Velocity is given in step_time_calc ns steps (see config), while the signal vector is given in step_time_out ns steps.","category":"page"}]
}
